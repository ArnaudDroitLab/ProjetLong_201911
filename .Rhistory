g1 = dbeta(prior, prop, 2)
g2 = dbeta(prop, prior, 2)
p = min(1,((p1*f1*g1) / (p2*f2*g2)))
return (p)
}
bacterie_freq <- function(n, x){
t <- rep(NA, n)
t[1] = runif(1,0,1)
if ( x<0 | x>100){
print('x doit être compris entre 0 et 100!')
return(NA)
}
for (i in 2:n+1){
#generation d'une liste de nombre aléatoire -> prior
prior = runif(1,0,1)
#loi de proposition -> beta
prop = beta(1,2)
p =  calc_p_accept(x, prior, prop)
pprime = runif(1,0,1)
if (pprime < p ){
t[i] = prior
}
else {
t[i] = t[i-1]
}
}
return (t)
}
sample_freq = bacterie_freq(100000, 70)
truehist(sample_freq, col='gray', xlab='θ', ylab='frequence θ')
abline(v=0.7, col='red')
bacterie_freq <- function(n, x){
t <- rep(NA, n)
t[1] = runif(1,0,1)
if ( x<0 | x>100){
print('x doit être compris entre 0 et 100!')
return(NA)
}
for (i in 2:n+1){
#generation d'une liste de nombre aléatoire -> prior
prior = runif(1,0,1)
#loi de proposition -> beta
prop = beta(1,2)
p =  calc_p_accept(x, prior, prop)
pprime = runif(1,0,1)
if (pprime < p ){
t[i] = prop
}
else {
t[i] = t[i-1]
}
}
return (t)
}
sample_freq = bacterie_freq(100000, 70)
truehist(sample_freq, col='gray', xlab='θ', ylab='frequence θ')
abline(v=0.7, col='red')
calc_p_accept <- function(x, prior, prop){
p1 = dunif(1,0,1)
p2 = dunif(1,0,1)
f1 = dbinom(x, size=100, prior)
f2 = dbinom(x, size=100, prop)
g1 = dbeta(prior, prop, 2)
g2 = dbeta(prop, prior, 2)
p = min(1,((p1*f1*g1) / (p2*f2*g2)))
return (p)
}
bacterie_freq <- function(n, x){
t <- rep(NA, n)
t[1] = runif(1,0,1)
if ( x<0 | x>100){
print('x doit être compris entre 0 et 100!')
return(NA)
}
for (i in 2:n+1){
#generation d'une liste de nombre aléatoire -> prior
prior = runif(1,0,1)
#loi de proposition -> beta
prop = beta(1,2)
p =  calc_p_accept(x, prior, prop)
pprime = runif(1,0,1)
if (pprime < p ){
t[i] = prop
}
else {
t[i] = t[i-1]
}
}
return (t)
}
sample_freq
bacterie_freq <- function(n, x){
t <- rep(NA, n)
t[1] = runif(1,0,1)
if ( x<0 | x>100){
print('x doit être compris entre 0 et 100!')
return(NA)
}
for (i in 2:n+1){
#generation d'une liste de nombre aléatoire -> prior
prior = runif(1,0,1)
#loi de proposition -> beta
prop = rbeta(1,2)
p =  calc_p_accept(x, prior, prop)
pprime = runif(1,0,1)
if (pprime < p ){
t[i] = prop
}
else {
t[i] = t[i-1]
}
}
return (t)
}
sample_freq = bacterie_freq(100000, 70)
bacterie_freq <- function(n, x){
t <- rep(NA, n)
t[1] = runif(1,0,1)
if ( x<0 | x>100){
print('x doit être compris entre 0 et 100!')
return(NA)
}
for (i in 2:n+1){
#generation d'une liste de nombre aléatoire -> prior
prior = runif(1,0,1)
#loi de proposition -> beta
prop = rbeta(1,1,2)
p =  calc_p_accept(x, prior, prop)
pprime = runif(1,0,1)
if (pprime < p ){
t[i] = prop
}
else {
t[i] = t[i-1]
}
}
return (t)
}
sample_freq = bacterie_freq(100000, 70)
truehist(sample_freq, col='gray', xlab='θ', ylab='frequence θ')
abline(v=0.7, col='red')
bacterie_freq <- function(n, x){
t <- rep(NA, n)
t[1] = runif(1,0,1)
if ( x<0 | x>100){
print('x doit être compris entre 0 et 100!')
return(NA)
}
for (i in 2:n+1){
#generation d'une liste de nombre aléatoire -> prior
prior = runif(1,0,1)
#loi de proposition -> beta
prop = rbeta(1,1,2)
p =  calc_p_accept(x, prior, prop)
pprime = runif(1,0,1)
if (pprime > p ){
t[i] = prop
}
else {
t[i] = t[i-1]
}
}
return (t)
}
sample_freq = bacterie_freq(100000, 70)
truehist(sample_freq, col='gray', xlab='θ', ylab='frequence θ')
abline(v=0.7, col='red')
sample_freq = bacterie_freq(100000, 70)
truehist(sample_freq, col='gray', xlab='θ', ylab='frequence θ')
abline(v=0.7, col='red')
sample_freq = bacterie_freq(100000, 70)
truehist(sample_freq, col='gray', xlab='θ', ylab='frequence θ')
abline(v=0.7, col='red')
calc_p_accept <- function(x, prior, prop){
p1 = dunif(1,0,1)
p2 = dunif(1,0,1)
f1 = dbinom(x, size=100, prob=prior)
f2 = dbinom(x, size=100, prob=prop)
g1 = dbeta(prior, prop, 2)
g2 = dbeta(prop, prior, 2)
p = min(1,((p1*f1*g1) / (p2*f2*g2)))
return (p)
}
calc_p_accept <- function(x, prior, prop){
p1 = dunif(1,0,1)
p2 = dunif(1,0,1)
f1 = dbinom(x, size=100, prob=prop)
f2 = dbinom(x, size=100, prob=prior)
g1 = dbeta(prior, prop, 2)
g2 = dbeta(prop, prior, 2)
p = min(1,((p1*f1*g1) / (p2*f2*g2)))
return (p)
}
bacterie_freq <- function(n, x){
t <- rep(NA, n)
t[1] = runif(1,0,1)
if ( x<0 | x>100){
print('x doit être compris entre 0 et 100!')
return(NA)
}
for (i in 2:n+1){
#generation d'une liste de nombre aléatoire -> prior
prior = runif(1,0,1)
#loi de proposition -> beta
prop = rbeta(1,1,2)
p =  calc_p_accept(x, prior, prop)
pprime = runif(1,0,1)
if (pprime < p ){
t[i] = prop
}
else {
t[i] = t[i-1]
}
}
return (t)
}
sample_freq = bacterie_freq(100000, 70)
truehist(sample_freq, col='gray', xlab='θ', ylab='frequence θ')
abline(v=0.7, col='red')
calc_p_accept <- function(x, prior, prop){
p1 = dunif(1,0,1)
p2 = dunif(1,0,1)
f1 = dbinom(x, size=100, prob=prop)
f2 = dbinom(x, size=100, prob=prior)
g1 = dbeta(prior, prop, 1)
g2 = dbeta(prop, prior, 1)
p = min(1,((p1*f1*g1) / (p2*f2*g2)))
return (p)
}
bacterie_freq <- function(n, x){
t <- rep(NA, n)
t[1] = runif(1,0,1)
if ( x<0 | x>100){
print('x doit être compris entre 0 et 100!')
return(NA)
}
for (i in 2:n+1){
#generation d'une liste de nombre aléatoire -> prior
prior = runif(1,0,1)
#loi de proposition -> beta
prop = rbeta(1,1,1)
p =  calc_p_accept(x, prior, prop)
pprime = runif(1,0,1)
if (pprime < p ){
t[i] = prop
}
else {
t[i] = t[i-1]
}
}
return (t)
}
sample_freq = bacterie_freq(100000, 70)
truehist(sample_freq, col='gray', xlab='θ', ylab='frequence θ')
abline(v=0.7, col='red')
#2
#un vector priori r unif et rbinm en utilisant 10000 theta pour choisir
#les valeurs dans la binomiale
#> conserver que les points qui correspondent à un x simulé > 70
n <- 10000
p.prior = runif(10000)
#loi de proposition
#nombre de succes
x = rbinom(n, size=100, prob=p.prior)
col = densCols(x, p.prior)
plot(x, p.prior, col=col)
#visualiser les données observés (70)
abline(v=70, col='orange')
p.posterior = p.prior[x == 70]
bacterie_freq_2 = function(n, x){
if ( x<0 | x>100){
print('x doit être compris entre 0 et 100!')
return(NA)
}
n <- 10000
p.prior = runif(n)
#loi de proposition
#nombre de succes
x1 = rbinom(n, size=100, prob=p.prior)
p.posterior = p.prior[x1 == x]
col = densCols(x1, p.prior)
plot(x1, p.prior, col=col)
abline(v=70, col='orange')
return(p.posterior)
}
p.posterior = bacterie_freq_2(100000, 70)
hist(p.posterior, col='gray', xlab='X', ylab='freq(θ|x=70)', prob=FALSE)
length(p.posterior)
truehist(p.posterior, col='gray', xlab='X', ylab='freq(θ|x=70)', prob=FALSE)
p.posterior = bacterie_freq_2(100000, 70)
truehist(p.posterior, col='gray', xlab='X', ylab='freq(θ|x=70)', prob=FALSE)
length(p.posterior)
p.posterior = bacterie_freq_2(100000, 70)
truehist(p.posterior, col='gray', xlab='θ', ylab='freq(θ|x=70)', prob=FALSE)
length(p.posterior)
truehist(p.posterior, col='gray', xlab='θ', ylab='freq(θ|x=70)', prob=FALSE)
abline(v=0.7, col='red')
truehist(p.posterior, col='gray', xlab='θ', ylab='freq(θ|x=70)', prob=FALSE, xlim=0)
truehist(p.posterior, col='gray', xlab='θ', ylab='freq(θ|x=70)', prob=FALSE, xlim=1)
p.posterior = bacterie_freq_2(100000, 70)
truehist(p.posterior, col='gray', xlab='θ', ylab='freq(θ|x=70)', prob=FALSE)
abline(v=0.7, col='red')
length(p.posterior)
bacterie_freq_2 = function(n, x){
if ( x<0 | x>100){
print('x doit être compris entre 0 et 100!')
return(NA)
}
p.prior = runif(n)
#loi de proposition
#nombre de succes
x1 = rbinom(n, size=100, prob=p.prior)
p.posterior = p.prior[x1 == x]
col = densCols(x1, p.prior)
plot(x1, p.prior, col=col)
abline(v=70, col='orange')
return(p.posterior)
}
p.posterior = bacterie_freq_2(100000, 70)
truehist(p.posterior, col='gray', xlab='θ', ylab='freq(θ|x=70)', prob=FALSE)
abline(v=0.7, col='red')
length(p.posterior)
ttest = t.test(p.posterior)
ttest
ttest = t.test(sample_freq)
print(ttest)
ttest2 = t.test(p.posterior)
print(ttest2)
bacterie_freq <- function(n, x){
t <- rep(NA, n)
t[1] = runif(1,0,1)
if ( x<0 | x>100){
print('x doit être compris entre 0 et 100!')
return(NA)
}
for (i in 2:n+1){
#generation d'une liste de nombre aléatoire -> prior
prior = runif(1,0,1)
#loi de proposition -> beta
prop = rbeta(1,1,1)
p =  calc_p_accept(x, prior, prop)
pprime = runif(1,0,1)
if (pprime < p ){
t[i] = prop
}
else {
t[i] = t[i-1]
}
}
return (t)
}
sample_freq = bacterie_freq(100000, 70)
truehist(sample_freq, col='gray', xlab='θ', ylab='frequence θ')
install.packages("phast")
install.packages("rphast")
fsATI=read.table(file='fsATI.csv', header=TRUE, sep=',')
setwd("~/M2_BIB/Projet_long/My_work")
setwd("~/M2_BIB/Projet_long/My_work")
fsATI=read.table(file='fsATI.csv', header=TRUE, sep=',')
View(fsATI)
fsATI=read.table(file='fsATI.csv', header=TRUE, sep=';')
View(fsATI)
View(fsATI)
print(fsATI['ORF'])
orf = fsATI['ORF']
View(orf)
View(orf)
vec_orf = as.vector(orf, mode="character")
print(vec_orf)
vec_orf = as.vector(fsATI['ORF'], mode="character")
vec_orf = c(NA, length(fsATI['ORF']), mode="character")
print(vec_orf)
vec_orf = rep(NA, length(fsATI['ORF']))
print(vec_orf)
taille = length(fsATI['ORF'])
vec_orf = rep(NA, 93)
orf = fsATI['ORF']
taille = length(orf)
vec_orf = rep(NA, 93)
print(vec_orf)
vec_orf = rep(NA, 93)
for (i in 1:93){
vec_orf[i] = orf[i]
}
print(orf[0])
print(orf[,0])
print(orf[0,])
vec_orf = rep(NA, 93)
for (i in 1:93){
vec_orf[i] = orf[i,]
}
print(vec_orf)
View(orf)
taille = nrow(orf)
orf = fsATI['ORF']
taille = nrow(orf)
vec_orf = rep(NA, taille)
for (i in 1:taille){
vec_orf[i] = orf[i,]
}
print(orf[0,])
print(fsATI$ORF[0,])
print(fsATI$ORF[0])
vec_orf <- as.vector(fsATI$ORF)
msa_object = msa(vec_orf, names = NULL, alphabet = "ACGT", is.ordered = TRUE,
offset = NULL, pointer.only = FALSE)
install.packages("rphast")
library(rphast)
msa_object = msa(vec_orf, names = NULL, alphabet = "ACGT", is.ordered = TRUE,
offset = NULL, pointer.only = FALSE)
vec_test = c('TACTTGCTTAATCGTACCAGT', 'TTTCTGCTTAATCGTACCAGT', 'TACTTGCGGCGTCGTACCAGT')
msa_object = msa(test, names = NULL, alphabet = "ACGT", is.ordered = TRUE,
offset = NULL, pointer.only = FALSE)
msa_object = msa(vec_test, names = NULL, alphabet = "ACGT", is.ordered = TRUE,
offset = NULL, pointer.only = FALSE)
View(msa_object)
View(msa_object)
vec_test = c('TACTTGCTTAATCGTACCAGT', 'TTTCTGCTTAATCGTACCAGT', 'TACTTGCGGCGTCGTACCAGT')
msa_object = msa(vec_test, names = NULL, alphabet = "ACGT", is.ordered = FALSE,
offset = NULL, pointer.only = FALSE)
print(msa_object)
msa_object = msa(vec_test, names = NULL, alphabet = "ACGT", is.ordered = TRUE,
offset = NULL, pointer.only = FALSE)
phyloFit(msa, tree = NULL, subst.mod = "REV", init.mod = NULL,
no.opt = c("backgd"), init.backgd.from.data = ifelse(is.null(init.mod),
TRUE, FALSE), features = NULL, scale.only = FALSE, scale.subtree = NULL,
nrates = NULL, alpha = 1, rate.constants = NULL, selection = NULL,
init.random = FALSE, init.parsimony = FALSE, clock = FALSE,
EM = FALSE, max.EM.its = NULL, precision = "HIGH", ninf.sites = 50,
quiet = FALSE, bound = NULL, log.file = FALSE)
phyloFit(msa, tree = NULL, subst.mod = "REV", init.mod = NULL,
no.opt = c("backgd"), init.backgd.from.data = ifelse(is.null(init.mod),
TRUE, FALSE), features = NULL, scale.only = FALSE, scale.subtree = NULL,
nrates = NULL, alpha = 1, rate.constants = NULL, selection = NULL,
init.random = FALSE, init.parsimony = FALSE, clock = FALSE,
EM = FALSE, max.EM.its = NULL, precision = "HIGH", ninf.sites = 50,
quiet = FALSE, bound = NULL, log.file = FALSE)
phyloFit(msa, tree = NULL, subst.mod = "REV", init.mod = NULL,
no.opt = c("backgd"), init.backgd.from.data = ifelse(is.null(init.mod),
TRUE, FALSE), features = NULL, scale.only = FALSE, scale.subtree = NULL,
nrates = NULL, alpha = 1, rate.constants = NULL, selection = NULL,
init.random = FALSE, init.parsimony = FALSE, clock = FALSE,
EM = FALSE, max.EM.its = NULL, precision = "HIGH", ninf.sites = 3,
quiet = FALSE, bound = NULL, log.file = FALSE)
phyloFit(msa_object, tree = NULL, subst.mod = "REV", init.mod = NULL,
no.opt = c("backgd"), init.backgd.from.data = ifelse(is.null(init.mod),
TRUE, FALSE), features = NULL, scale.only = FALSE, scale.subtree = NULL,
nrates = NULL, alpha = 1, rate.constants = NULL, selection = NULL,
init.random = FALSE, init.parsimony = FALSE, clock = FALSE,
EM = FALSE, max.EM.its = NULL, precision = "HIGH", ninf.sites = 3,
quiet = FALSE, bound = NULL, log.file = FALSE)
phyloFit(msa_object, tree = 'hg38', subst.mod = "REV", init.mod = NULL,
no.opt = c("backgd"), init.backgd.from.data = ifelse(is.null(init.mod),
TRUE, FALSE), features = NULL, scale.only = FALSE, scale.subtree = NULL,
nrates = NULL, alpha = 1, rate.constants = NULL, selection = NULL,
init.random = FALSE, init.parsimony = FALSE, clock = FALSE,
EM = FALSE, max.EM.its = NULL, precision = "HIGH", ninf.sites = 3,
quiet = FALSE, bound = NULL, log.file = FALSE)
phyloFit(msa_object, tree = 'hg38', subst.mod = "REV",
no.opt = c("backgd"), init.backgd.from.data = ifelse(is.null(init.mod),
TRUE, FALSE), features = NULL, scale.only = FALSE, scale.subtree = NULL,
nrates = NULL, alpha = 1, rate.constants = NULL, selection = NULL,
init.random = FALSE, init.parsimony = FALSE, clock = FALSE,
EM = FALSE, max.EM.its = NULL, precision = "HIGH", ninf.sites = 3,
quiet = FALSE, bound = NULL, log.file = FALSE)
phyloFit(msa_object, tree = 'hg38', subst.mod = "REV",
no.opt = c("backgd"), init.backgd.from.data = ifelse(is.null(init.mod),
TRUE, FALSE), features = NULL, scale.only = FALSE, scale.subtree = NULL,
nrates = NULL, alpha = 1, rate.constants = NULL, selection = NULL,
init.random = FALSE, init.parsimony = FALSE, clock = FALSE,
EM = FALSE, max.EM.its = NULL, precision = "HIGH", ninf.sites = 3,
quiet = FALSE, bound = NULL, log.file = FALSE)
phyloFit(msa_object, tree = 'hg38')
phyloFit(msa_object, tree = 'hg38, hg38, hg38')
phyloFit(msa_object, tree = 'hg38, hg38, hg38', init.mod = NULL)
mod_object = phyloFit(msa_object, tree = 'hg38, hg38, hg38', init.mod = NULL)
phyloFit --tree "((galGal2,((rn3,mm5),fr1)),hg17)" --subst-mod REV --out-root modelfile alignment.maf
#Fit a Phylogenetic model to an alignment
mod_object = phyloFit(msa_object, tree = 'hg38, hg38, hg38', init.mod = NULL)
subst.mod()
subst.mods()
#Fit a Phylogenetic model to an alignment
mod_object = phyloFit(msa_object, tree='hg38, hg38, hg38', init.mod=NULL, subst.mod='K80')
#Fit a Phylogenetic model to an alignment
mod_object = phyloFit(msa_object, tree='s1, s2, s3', init.mod=NULL, subst.mod='K80')
init.modes()
init.mods()
setwd("~/M2_BIB/Projet_long/My_work")
fsATI = read.table(file='fsATI.csv', header=TRUE, sep=';')
vec_orf <- as.vector(fsATI$ORF)
vec_test = c('TACTTGCTTAATCGTACCAGT', 'TTTCTGCTTAATCGTACCAGT',
'TACTTGCGGCGTCGTACCAGT')
#Create a MSA object from sequences
msa_object = msa(vec_test, names=NULL, alphabet="ACGT", is.ordered=TRUE,
offset=NULL, pointer.only=FALSE)
print(msa_object)
#Fit a Phylogenetic model to an alignment
mod_object = phyloFit(msa_object, tree='s1, s2, s3', init.mod=NULL,
subst.mod='REV', bound=NULL)
subst.modes()
subst.mods()
#Create a MSA object from sequences
msa_object = msa(vec_orf, names=NULL, alphabet="ACGT", is.ordered=TRUE,
offset=NULL, pointer.only=FALSE)
#Create a MSA object from sequences
msa_object = msa(vec_test, names=NULL, alphabet="ACGT", is.ordered=TRUE,
offset=NULL, pointer.only=FALSE)
print(msa_object)
#Fit a Phylogenetic model to an alignment
mod_object = phyloFit(msa_object, tree='s1, s2, s3', init.mod=NULL,
subst.mod='REV', bound=NULL)
?msa
